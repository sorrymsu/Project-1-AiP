"""2048 Game Logic

Модуль предоставляет основную логику для игры "2048". Он включает в себя функции
для управления игровым полем, выполнения ходов и обновления состояния игры.

Атрибуты:
    FILENAME (str): Имя файла для хранения и извлечения лучшего результата.

Функции:
    main: Основная функция для запуска игры "2048".
    print_intro: Вывод приветственного сообщения для игры.
    get_high_score: Получение лучшего результата из файла.
    get_new_board: Создание нового игрового поля.
    board_is_full: Проверка, полное ли игровое поле.
    add_random_number: Добавление случайного числа на игровое поле.
    print_board: Вывод текущего состояния игрового поля.
    print_scores: Вывод счета игрока и лучшего результата.
    get_valid_move: Получение допустимого хода от игрока.
    update_board: Обновление игрового поля в соответствии с ходом игрока.
    move_up: Перемещение чисел на игровом поле вверх.
    move_left: Перемещение чисел на игровом поле влево.
    move_down: Перемещение чисел на игровом поле вниз.
    move_right: Перемещение чисел на игровом поле вправо.
    print_results: Вывод окончательных результатов игры.
    has_won: Проверка, выиграл ли игрок игру.
    get_valid_answer: Получение допустимого ответа (да/нет) от игрока.
    save_high_score: Сохранение лучшего результата в файл.
    print_outro: Вывод завершающего сообщения для игры.
"""
from random import randint, choice

FILENAME = "2048_high_score.txt"


def main():
    """
        Основная функция для запуска игры "2048".

        Выводит приветственное сообщение, получает лучший результат из файла,
        итеративно создает новое игровое поле, обновляет счет и состояние игры,
        выводит текущее состояние и результаты до тех пор, пока игрок решает завершить игру.

        Returns:
            None
        """
    # Выводим приветственное сообщение
    print_intro()
    # Получаем лучший результат из файла
    high_score = get_high_score()
    # Флаг для продолжения игры
    wants_to_play = True

    while wants_to_play:
        # Создаем новое игровое поле
        board = get_new_board()
        # Счет игрока
        score = 0
        # Направление движения
        move = None

        while not (board_is_full(board) or move == "r"):
            # Добавляем новое число на поле
            add_random_number(board)
            # Выводим текущее состояние игры
            print_board(board, score, high_score)
            # Получаем от игрока направление движения
            move = get_valid_move()
            # Обновляем состояние игры в соответствии с выбранным направление
            score += update_board(board, move)

            # Если текущий счет превысил лучший результат, обновляем его
            if score > high_score:
                high_score = score

        # Выводим конечное состояние игры и результаты
        print_board(board, score, high_score)
        print_results(board, score, high_score)
        # Спрашиваем, хочет ли игрок сыграть еще раз
        wants_to_play = get_valid_answer()

    # Сохраняем лучший результат в файл
    save_high_score(high_score)
    print_outro()


# Приветственное сообщение
def print_intro():
    """
        Выводит приветственное сообщение.

        Returns:
            str: напечатает приветственное сообщение.
        """
    print("Добро пожаловать в игру \"2048\"!\n")


# Получение лучшего результата из файла
def get_high_score():
    """
        Получает лучший результат из файла.

        Returns:
            int: Лучший результат, если данные корректны.
                 Возвращает 0, если файл не найден или данные некорректны.

        Raises:
            FileNotFoundError: Если файл с лучшими результатами не найден.
            ValueError: Если данные в файле с лучшими результатами некорректны.
        """
    try:
        with open(FILENAME) as file:
            data = file.read().strip()
            if data.isdecimal():
                return int(data)
        print("Файл с лучшими результатами содержит некорректные данные.\n")
        return 0
    except (FileNotFoundError, ValueError):
        return 0


# Создание нового игрового поля
def get_new_board():
    """
        Создает новое игровое поле.

        Игровое поле представляет собой список из 16 элементов, инициализированных
        нулями. Затем на поле добавляется случайное число.

        Returns:
            list: Новое игровое поле.
        """
    board = [0 for _ in range(16)]
    add_random_number(board)
    return board


# Проверка, полное ли игровое поле
def board_is_full(board):
    """
        Проверяет, полное ли игровое поле.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.

        Returns:
            bool: True, если игровое поле полное, False в противном случае.
        """
    for cell in board:
        if cell == 0:
            return False
    return True


# Добавление случайного числа на поле
def add_random_number(board):
    """
        Добавляет случайное число на игровое поле.

        Генерирует случайное число (4 с вероятностью 1/10, иначе 2) и добавляет
        его на игровое поле в одну из пустых ячеек.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.
        """
    number = 4 if randint(1, 10) == 1 else 2
    empty_cells = []
    for i in range(len(board)):
        if board[i] == 0:
            empty_cells.append(i)
    board[choice(empty_cells)] = number


# Вывод игрового поля
def print_board(board, score, high_score):
    """
        Выводит текущее состояние игрового поля.

    Функция отвечает за отображение текущего состояния игрового поля в виде
    консольной таблицы. Выводит числа на игровом поле и отражает текущий счет
    игрока и лучший результат.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.
            score (int): Счет игрока.
            high_score (int): Лучший результат.

        Returns:
            напечатает поле 4 на 4, и вверху отобразит 2048 в специально переданном виде
        """
    print("-------======= 2 0 4 8 =======-------\n")
    print_scores(score, high_score)
    print("+--------+--------+--------+--------+")
    for y in range(4):
        for i in range(3):
            print("|", end="")
            for x in range(4):
                index = y * 4 + x
                if i != 1 or board[index] == 0:
                    print("        ", end="")
                else:
                    spaces = (8 - len(str(board[index]))) // 2
                    print(" " * (spaces + len(str(board[index])) % 2), end="")
                    print(board[index], end="")
                    print(" " * spaces, end="")
                print("|", end="")
            print()
        print("+--------+--------+--------+--------+")
    print()


# Вывод счета и лучшего результата
def print_scores(score, high_score):
    """
        Выводит текущий счет игрока и лучший результат.

        Args:
            score (int): Текущий счет игрока.
            high_score (int): Лучший результат.

        Returns:
            None

        Example:
            Пример использования:
            >>> print_scores(24, 48)
              SCORE:   24       HI:     48

        """
    print(f"  SCORE:   {score}{' ' * (9 - len(str(score)))}HI:     {high_score}")


# Получение от игрока направления движения
def get_valid_move():
    """
        Получает от игрока ввод с выбором направления или перезапуска игры.

        Функция запрашивает у игрока ввод, предлагая выбрать направление (W, A, S, D)
        для движения вверх, влево, вниз или вправо соответственно. Также предоставляется
        возможность ввести 'R' для перезапуска игры.

        Returns:
            str: Введенное направление.

        Example:
            Пример использования:
            >>> get_valid_move()
            Введите WASD для выбора направления или R для перезапуска игры: w
            'w'
        """
    move = input("Введите WASD для выбора направления или R для перезапуска игры: ").lower()
    while move not in tuple("wasdr"):
        move = input("Введите W, A, S, D или R: ").lower()
    print()
    return move


# Обновление состояния игры в соответствии с выбранным направлением
def update_board(board, move):
    """
        Обновляет состояние игрового поля в соответствии с выбранным направлением.

        Функция принимает текущее состояние игрового поля и направление, выбранное
        игроком, и обновляет поле в соответствии с этим направлением. В случае
        перезапуска игры (выбор 'R'), возвращает 0.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.
            move (str): Выбранное направление ('w', 'a', 's', 'd', 'r').

        Returns:
            int: Текущий счет игрока после обновления.

        Example:
            Пример использования:
            >>> update_board([2, 0, 4, 8, 4, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0], 'w')
            24
        """
    global score
    if move == "w":
        score = move_up(board)
    elif move == "a":
        score = move_left(board)
    elif move == "s":
        score = move_down(board)
    elif move == "d":
        score = move_right(board)
    elif move == "r":
        return 0
    return score


# Движение вверх
def move_up(board):
    """
        Выполняет движение вверх на игровом поле и объединяет одинаковые числа.

        Функция перемещает все числа вверх на игровом поле и объединяет
        соседние числа с одинаковыми значениями. Если числа объединяются,
        сумма добавляется к общему счету. Возвращает счет, который
        был получен при объединении.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.
                Игровое поле представляет собой одномерный список из 16 элементов.

        Returns:
            int: Счет, полученный при объединении чисел в процессе движения вверх.

        Note:
            Игровое поле представляет собой одномерный список размером 16 элементов,
            где элементы расположены в виде 4x4 матрицы. Первые четыре элемента
            соответствуют верхнему ряду матрицы, следующие четыре - второму ряду и
            так далее.
        """
    score = 0
    merged = []
    for i in range(4, 16):
        while i > 3 and board[i - 4] == 0:
            board[i - 4] = board[i]
            board[i] = 0
            i -= 4
        if i > 3 and board[i - 4] == board[i] and i - 4 not in merged:
            board[i - 4] *= 2
            merged.append(i - 4)
            score += board[i - 4]
            board[i] = 0
    return score


# Движение влево
def move_left(board):
    """
        Выполняет движение влево на игровом поле и объединяет одинаковые числа.

        Функция перемещает все числа влево на игровом поле и объединяет
        соседние числа с одинаковыми значениями. Если числа объединяются,
        сумма добавляется к общему счету. Возвращает счет, который
        был получен при объединении.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.
                Игровое поле представляет собой одномерный список из 16 элементов.

        Returns:
            int: Счет, полученный при объединении чисел в процессе движения влево.

        Note:
            Игровое поле представляет собой одномерный список размером 16 элементов,
            где элементы расположены в виде 4x4 матрицы. Первые четыре элемента
            соответствуют верхнему ряду матрицы, следующие четыре - второму ряду и
            так далее.
        """
    score = 0
    merged = []
    for i in range(1, 16):
        while i % 4 != 0 and board[i - 1] == 0:
            board[i - 1], board[i] = board[i], 0
            i -= 1
        if i % 4 != 0 and board[i - 1] == board[i] and i - 1 not in merged:
            board[i - 1] *= 2
            merged.append(i - 1)
            score += board[i - 1]
            board[i] = 0
    return score


# Движение вниз
def move_down(board):
    """
        Выполняет движение вниз на игровом поле и объединяет одинаковые числа.

        Функция перемещает все числа вниз на игровом поле и объединяет
        соседние числа с одинаковыми значениями. Если числа объединяются,
        сумма добавляется к общему счету. Возвращает счет, который
        был получен при объединении.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.
                Игровое поле представляет собой одномерный список из 16 элементов.

        Returns:
            int: Счет, полученный при объединении чисел в процессе движения вниз.

        Note:
            Игровое поле представляет собой одномерный список размером 16 элементов,
            где элементы расположены в виде 4x4 матрицы. Первые четыре элемента
            соответствуют верхнему ряду матрицы, следующие четыре - второму ряду и
            так далее.
        """
    score = 0
    merged = []
    for i in range(11, -1, -1):
        while i < 12 and board[i + 4] == 0:
            board[i + 4] = board[i]
            board[i] = 0
            i += 4
        if i < 12 and board[i + 4] == board[i] and i + 4 not in merged:
            board[i + 4] *= 2
            merged.append(i + 4)
            score += board[i + 4]
            board[i] = 0
    return score


# Движение вправо
def move_right(board):
    """
        Выполняет движение вправо на игровом поле и объединяет одинаковые числа.

        Функция перемещает все числа вправо на игровом поле и объединяет
        соседние числа с одинаковыми значениями. Если числа объединяются,
        сумма добавляется к общему счету. Возвращает счет, который
        был получен при объединении.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.
                Игровое поле представляет собой одномерный список из 16 элементов.

        Returns:
            int: Счет, полученный при объединении чисел в процессе движения вправо.

        Note:
            Игровое поле представляет собой одномерный список размером 16 элементов,
            где элементы расположены в виде 4x4 матрицы. Первые четыре элемента
            соответствуют верхнему ряду матрицы, следующие четыре - второму ряду и
            так далее.
        """
    score = 0
    merged = []
    for i in range(14, -1, -1):  # начинаем с последнего элемента и двигаемся влево
        while i % 4 != 3 and board[i + 1] == 0:
            board[i + 1], board[i] = board[i], 0
            i += 1
        if i % 4 != 3 and board[i + 1] == board[i] and i + 1 not in merged:
            board[i + 1] *= 2
            merged.append(i + 1)
            score += board[i + 1]
            board[i] = 0
    return score


# Вывод результатов
def print_results(board, score, high_score):
    """
        Выводит результаты игры, оповещает о победе или поражении, а также
        отображает финальный счет и рекорд.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.
            score (int): Текущий счет игрока.
            high_score (int): Лучший результат игрока.

        Returns:
            напечатает поздравление иначе проигрыш.
        """
    if has_won(board):
        print("Поздравляю! вы выиграли")
    else:
        print("К сожалению вы проиграли...")
    print(f"Ваш финальный результат: {score}")
    if score == high_score:
        print("Вы установили рекорд")
    print()


# Проверка, выиграл ли игрок
def has_won(board):
    """
        Проверяет, выиграл ли игрок, достигнув значения 2048 или более в ячейке.

        Args:
            board (list): Список, представляющий текущее состояние игрового поля.

        Returns:
            bool: Возвращает True, если игрок выиграл, иначе False.

        Example:
            Пример использования:
            >>> has_won([2, 0, 4, 8, 4, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2048])
            True
        """
    for cell in board:
        if cell >= 2048:
            return True
    return False


# Получение ответа от игрока на вопрос о продолжении игры
def get_valid_answer():
    """
        Запрашивает ответ от игрока на вопрос о продолжении игры.

        Returns:
            bool: Возвращает True, если игрок хочет сыграть снова, иначе False.

        Example:
            Пример использования:
            >>> get_valid_answer()
            Хотите сыграть снова? (да/нет): да
            True
        """
    answer = input("Хотите сыграть снова? (да/нет): ").lower()
    while answer not in ("да", "нет"):
        answer = input("Просто ответьте \"да\" или \"нет\": ").lower()
    print()
    return False if answer == "нет" else True


# Сохранение лучшего результата в файл
def save_high_score(high_score):
    """
        Сохраняет лучший результат в файл.

        Args:
            high_score (int): Лучший результат для сохранения.

        Example:
            Пример использования:
            >>> save_high_score(500)
        """
    try:
        with open(FILENAME, "w") as file:
            file.write(str(high_score))
    except OSError:
        print("Невозможно записать лучший результат в файл.\n")


# Вывод прощального сообщения
def print_outro():
    """
        Выводит прощальное сообщение и ожидает нажатия клавиши ENTER для завершения игры.

        Example:
            Пример использования:
            >>> print_outro()
            Спасибо
            Нажмите ENTER для окончания игры.
        """
    print("Спасибо")
    input("Нажмите ENTER для окончания игры. ")


if __name__ == "__main__":
    main()
